闭包
1： 作用域，
    1，全局作用域
    2，函数作用域
        在函数执行的时候，会有一个临时对象（活动对象，作用域对象），函数的this对象，就是在这个活动对象里，当函数执行完成后，该对象就消失了
作用域链
    函数都有一个window的作用域, function() 声明的话，会变量提升，在函数还未调用的时候，就会有window作用域，字面量的要在调用的时候，才有window作用

活动对象上有__parent__属性，函数体上面有scope属性，作用域链
为什么要使用闭包？
    希望重用一个对象，又保护对象不被污染篡改时


如果在body 中写了script标签，浏览看会阻塞，合理吗？合理的，如果script标签里面对dom进行了更改，那前面的渲染就没啥意义
script 
    1，async 和 defer 的一个区别就是async 的脚本只要加载完成就执行，defer是一定等到dom结束后
    2，async 哪个先加载完就先执行，和代码顺序无关，defer严格按照脚本代码顺序




dns 解析地址



对于网页来说，需要两个线程，一个是GUI渲染线程，一个是js引擎线程，js是单线程的，也就是说，一次只能干一件事，这两个线程同时
只能做一件事，也就是说这两个线程是互斥的。脚本时，⻚面是不可响应的，直到脚本已完成。









链接：https://juejin.cn/post/7054434354071601166

作用域只存在于函数体的大括号中

[[scope]] 内部属性 ，全局作用域链接
local 是函数体自身的作用域，也就是函数作用域内部，在局部作用域里面存放this, 然后才是作用域链，
调用外层函数时，自动创建外层函数的函数作用域对象，保存着外层函数的局部变量，讲这个函数作用域对象传递给retutn的子函数


为什么闭包 内存泄漏？
为什么闭包可以访问另一个函数的变量

闭包的作用域链，内层函数的作用域对象，外层函数的作用域对象，全局作用域丢下

所有函数调用完，要清空，但是只清空离自己最近的一个作用域

闭包形成的原因是什么？ 外层函数的作用域对象被内层使用，无法释放掉


var a = 10;
debugger
function test(){
    debugger
    var a = 20;
    console.log(a)
}